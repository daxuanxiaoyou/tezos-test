"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateMissingInterfaces = exports.validateInterfaces = exports.validateAuthor = exports.validateTzip16 = void 0;
const ajv_1 = __importDefault(require("ajv"));
const tzip16_metadata_schema_json_1 = __importDefault(require("./schemas/tzip16-metadata-schema.json"));
const v = __importStar(require("./meta-validators"));
const is_email_1 = __importDefault(require("is-email"));
/**
 * Validate contract metadata format in accordance with TZIP-16 standard
 * @param meta object representing contract metadata.
 * @returns list of validation errors and/or warnings. Each error string starts
 * with `Error:` prefix and each warning string starts with `Warning:` prefix.
 */
function validateTzip16(meta) {
    const ajv = new ajv_1.default();
    ajv.validate(tzip16_metadata_schema_json_1.default, meta);
    const schemaErrors = ajv.errors
        ? ajv.errors.map(e => `Error: ${e.instancePath} ${e.message}`)
        : [];
    // return ajv.errors?.map(e => JSON.stringify(e));
    const heuristics = validateHeuristic(meta);
    const heuristicErrors = [...heuristics].flat();
    return [...schemaErrors, ...heuristicErrors];
}
exports.validateTzip16 = validateTzip16;
function* validateHeuristic(meta) {
    const nonEmptyString = v.validateNonEmptyString(meta);
    yield v.validateRequired(meta)('name');
    yield nonEmptyString('name');
    yield v.validateRecommended(meta)('description');
    yield nonEmptyString('description');
    yield validateDescription(meta);
    yield nonEmptyString('homepage');
    yield validateHomepage(meta);
    yield v.validateUri(meta)('homepage');
    yield nonEmptyString('version');
    yield [...validateAuthors(meta)].flat();
    const ifaceFmtValidation = validateInterfaces(meta);
    if (ifaceFmtValidation.length > 0)
        yield ifaceFmtValidation;
    else
        yield validateMissingInterfaces(meta);
}
function validateDescription(meta) {
    if (meta.description && meta.description === 'Awesome NFT collection')
        return [
            'Warning: It looks like "description" has a sample value. Replace with a real description or remove it'
        ];
    return [];
}
function validateHomepage(meta) {
    if (meta.homepage &&
        meta.homepage === 'https://github.com/oxheadalpha/nft-tutorial')
        return [
            'Warning: It looks like "homepage" has a sample value. Replace with a real URL or remove it'
        ];
    return [];
}
const sampleAuthor = 'John Doe <john.doe@johndoe.com>';
function* validateAuthors(meta) {
    const authors = meta.authors;
    if (!authors)
        return;
    if (authors.find(a => a === sampleAuthor))
        yield [
            `Warning: It looks like one of the authors is a sample '${sampleAuthor}'. Replace with a real author e-mail or URL or remove it`
        ];
    yield authors
        .filter(a => !validateAuthor(a))
        .map(a => `Error: Author "${a}" in "authors" has invalid format. Author should be in form "Print Name <e-mail_or_url>"`);
}
function validateAuthor(author) {
    const parts = author
        .split(' ')
        .map(p => p.trim())
        .filter(p => p !== '');
    if (parts.length < 2)
        return false;
    const quoted_email_or_url = parts.at(-1);
    if (!(quoted_email_or_url === null || quoted_email_or_url === void 0 ? void 0 : quoted_email_or_url.startsWith('<')) &&
        !(quoted_email_or_url === null || quoted_email_or_url === void 0 ? void 0 : quoted_email_or_url.endsWith('>')))
        return false;
    const email_or_url = quoted_email_or_url.substring(1, quoted_email_or_url.length - 1);
    return (0, is_email_1.default)(email_or_url) || v.isValidUri(email_or_url);
}
exports.validateAuthor = validateAuthor;
function validateInterfaces(meta) {
    if (!meta.interfaces || meta.interfaces.length === 0)
        return ['Warning: consider adding "inrefaces": ["TZIP-012", "TZIP-021"]'];
    return meta.interfaces.flatMap(validateInterface);
}
exports.validateInterfaces = validateInterfaces;
function validateInterface(iface) {
    const invalidFormat = `Error: Invalid interface spec format in "${iface}".`;
    if (!iface.startsWith('TZIP-'))
        return [`${invalidFormat} Required format is TZIP-XXX`];
    const ifaceSpec = iface.substring('TZIP-'.length);
    const [ifaceNumber, extra] = ifaceSpec.split(' ');
    if (ifaceNumber.length !== 3)
        return [`${invalidFormat} Required format is TZIP-XXX`];
    const num = Number.parseInt(ifaceNumber);
    if (Number.isNaN(num))
        return [
            `${invalidFormat} Interface specification must be a 3 digit number as TZIP-XXX [<extra>]`
        ];
    return [];
}
function validateMissingInterfaces(meta) {
    const ifaceNums = meta.interfaces
        ? meta.interfaces.map(parseInterfaceNumber)
        : [];
    if (!ifaceNums.find(s => s === 12))
        return ['Warning: consider specifying FA2 interface TZIP-012'];
    if (!ifaceNums.find(s => s === 21))
        return [
            'Warning: consider specifying rich token metadata interface TZIP-021'
        ];
    return [];
}
exports.validateMissingInterfaces = validateMissingInterfaces;
function parseInterfaceNumber(iface) {
    const prefixLength = 'TZIP-'.length;
    const spec = iface.substring(prefixLength, prefixLength + 3);
    return Number.parseInt(spec);
}
//# sourceMappingURL=validate-tzip16.js.map